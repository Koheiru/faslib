<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="faslib : faslib, C++, AOP, Type list" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>faslib</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/migashko/faslib">View on GitHub</a>

          <h1 id="project_title">faslib</h1>
          <h2 id="project_tagline">faslib, C++, AOP, Type list</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/migashko/faslib/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/migashko/faslib/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>faslib</h1>

<p>Библиотека faslib предлагает новый способ модульной разработки программного обеспечения,
называемый аспекто-ориентированным, используя исключительно конструкции языка C++.</p>

<p>faslib тестировалась на следующих компиляторах:</p>

<ul>
<li>VC10</li>
<li>g++ 3.3, g++ 4.4, g++ 4.6, g++ 4.7</li>
<li>MinGW</li>
</ul><h2>Установка и настройка</h2>

<p>Компиляция не требуется, но необходимо конфигурирование с помощью cmake:</p>

<pre><code>git clone git://github.com/migashko/faslib.github
cd faslib
mkdir build
cd build
cmake ..
</code></pre>

<p>Вы также можете загрузить сконфигурированный faslib c <a href="https://sourceforge.net/projects/faslib2">sourceforge</a>.</p>

<p>Для компиляции примеров и тестов:</p>

<pre><code>make
</code></pre>

<p>или по отдельности:</p>

<pre><code>make tests
make examples
make tutorial
</code></pre>

<p>для запуска тестов:</p>

<pre><code>ctest
</code></pre>

<h2>Введение</h2>

<p>Основная идея - дать разработчику возможность разрабатывать такие классы, в которых потенциальный пользователь, при необходимости, мог бы заменить тот или иной функционал с минимумом издержек. faslib поможет вам когда:</p>

<ul>
<li>количество шаблонных стратегий для класса больше трех</li>
<li>семантически идентичный функционал используется в нескольких, не связанных между собой, классах</li>
<li>требуется заменить существующий функционал класса (реализацию одного или нескольких методов)</li>
</ul><p>В качестве примера рассмотрим простой класс:</p>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">foo1</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">method1</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-1.1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">method2</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-1.2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">method3</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-1.3"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>Предположим требуется предоставить пользователю возможность заменить функционал любого методов этого класса.
Использовать для этого полиморфизм - не лучшая идея, классические стратегии слишком накладно, шаблонные стратегии
неудобно. Более развернутые примеры (в том числе и с этими вариантами реализации) вы можете найти в <a href="https://github.com/migashko/faslib/tree/master/tutorial/aop">tutorial/aop</a>.</p>

<p>Для наглядности изобразим этот класс на картинке в виде монолитного блока:</p>

<p><img src="http://i.imgur.com/ovInI.png" alt="foo"></p>

<p>Для демонстрации возможностей разработаем класс foo2 с аналогичным функционалом, но используя концепции АОП.
Сначала разобьем его на составляющие, выделив каждый метод в отдельные сущности которые в faslib называются адвайс-классами:</p>

<p><img src="http://i.imgur.com/n2diQ.png" alt="ad_method"></p>

<div class="highlight"><pre><span class="k">struct</span> <span class="n">ad_method1</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-2.1"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ad_method2</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-2.2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ad_method3</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-2.3"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>Каких либо особых требований к адвайс-классам не предъявляется, но использование определенных правил
при разработке адвайс-классов существенно облегчит жизнь и вам и потенциальным пользователям. Использование перегруженного
оператора () с первым шаблонным параметром, в который передается контекст вызова (в данном случае это ссылка на foo2) является
хорошей практикой, даже если в конкретном адвайс-классе он не нужен. Дело в том, что ссылка на контекст может очень понадобиться
пользователю, который решит заменить ваш адвайс своим. Префикс “ad_” подскажет пользователю, что он имеет дело с адвайс-классом.</p>

<p>Далее для каждого адвайс-класса необходимо создать тег, по которому мы сможем обращаться к нему. Методов у нас три поэтому и
тегов нам понадобиться тоже как минимум три:</p>

<div class="highlight"><pre><span class="k">struct</span> <span class="n">_method1_</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">_method2_</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">_method3_</span><span class="p">;</span>
</pre></div>

<p>Использование знака “_” для обрамления имени тега, чертовски удобная штука.
Следующим этапом необходимо связать теги и адвайс-классы, создав таким образом собственно адвайсы:</p>

<p><img src="http://i.imgur.com/mof7U.png" alt="advices"></p>

<div class="highlight"><pre><span class="k">typedef</span> <span class="n">fas</span><span class="o">::</span><span class="n">advice</span><span class="o">&lt;</span><span class="n">_method1_</span><span class="p">,</span> <span class="n">ad_method1</span><span class="o">&gt;</span> <span class="n">method1_advice</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">fas</span><span class="o">::</span><span class="n">advice</span><span class="o">&lt;</span><span class="n">_method2_</span><span class="p">,</span> <span class="n">ad_method2</span><span class="o">&gt;</span> <span class="n">method2_advice</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">fas</span><span class="o">::</span><span class="n">advice</span><span class="o">&lt;</span><span class="n">_method3_</span><span class="p">,</span> <span class="n">ad_method3</span><span class="o">&gt;</span> <span class="n">method3_advice</span><span class="p">;</span>
</pre></div>

<p>Далее, необходимо объединить  разрозненные адвайсы в список типов:</p>

<p><img src="http://i.imgur.com/69b5W.png" alt="advice_list"></p>

<div class="highlight"><pre><span class="k">typedef</span> <span class="n">fas</span><span class="o">::</span><span class="n">type_list_n</span><span class="o">&lt;</span>
  <span class="n">method1_advice</span><span class="p">,</span>
  <span class="n">method2_advice</span><span class="p">,</span>
  <span class="n">method3_advice</span>
<span class="o">&gt;::</span><span class="n">type</span> <span class="n">advice_list</span><span class="p">;</span>
</pre></div>

<p>Cформируем аспект foo2_aspect:</p>

<p><img src="http://i.imgur.com/KJeJq.png" alt="foo2_aspect"></p>

<div class="highlight"><pre><span class="k">struct</span> <span class="nl">foo2_aspect:</span> <span class="n">fas</span><span class="o">::</span><span class="n">aspect</span><span class="o">&lt;</span> <span class="n">advice_list</span> <span class="o">&gt;</span><span class="p">{};</span>
</pre></div>

<p>Ну и наконец разработаем сам аспектный класс foo2, в который внедрим аспект foo2_aspect:</p>

<div class="highlight"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span> <span class="o">=</span> <span class="n">fas</span><span class="o">::</span><span class="n">aspect</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">foo2</span>
  <span class="o">:</span> <span class="k">public</span> <span class="n">fas</span><span class="o">::</span><span class="n">aspect_class</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">foo2_aspect</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">method1</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">get_aspect</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">_method1_</span><span class="o">&gt;</span><span class="p">()(</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">method2</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">get_aspect</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">_method2_</span><span class="o">&gt;</span><span class="p">()(</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">method3</span><span class="p">()</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">get_aspect</span><span class="p">().</span><span class="k">template</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">_method3_</span><span class="o">&gt;</span><span class="p">()(</span> <span class="o">*</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>В реализации методов делегируем вызов необходимому адвайсу. Но в большинстве случаев компилятор выполнит inline подстановку.</p>

<p>Использовать аспектный класс foo2&lt;&gt; не сложнее обычного foo1:</p>

<div class="highlight"><pre>  <span class="n">foo2</span><span class="o">&lt;&gt;</span> <span class="n">f2</span><span class="p">;</span>
  <span class="n">f2</span><span class="p">.</span><span class="n">method1</span><span class="p">();</span>
  <span class="n">f2</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span>
  <span class="n">f2</span><span class="p">.</span><span class="n">method3</span><span class="p">();</span>
</pre></div>

<p>Класс   foo2&lt;&gt; изобразим следующим образом:</p>

<p><img src="http://i.imgur.com/BNWNa.png" alt="foo2_aspect"></p>

<p>Полный пример <a href="https://github.com/migashko/faslib/blob/master/examples/aop/foo.cpp">здесь</a></p>

<p>Теперь попробуем заменить функционал method2 и method3, чтобы он выводил вместо строк "method-2.2" и "method-2.3", строки "method-3.2" и "method-3.3" соответственно. </p>

<p>Для этого аналогично сформируем аспект foo3_aspect:</p>

<p><img src="http://i.imgur.com/I0dIb.png" alt="foo3_aspect"></p>

<div class="highlight"><pre><span class="k">struct</span> <span class="n">ad_method3_2</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-3.2"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ad_method3_3</span>
<span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"method-3.3"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nl">foo3_aspect:</span> <span class="n">fas</span><span class="o">::</span><span class="n">aspect</span><span class="o">&lt;</span> <span class="n">fas</span><span class="o">::</span><span class="n">type_list_n</span><span class="o">&lt;</span>
  <span class="n">fas</span><span class="o">::</span><span class="n">advice</span><span class="o">&lt;</span><span class="n">_method2_</span><span class="p">,</span> <span class="n">ad_method3_2</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">fas</span><span class="o">::</span><span class="n">advice</span><span class="o">&lt;</span><span class="n">_method3_</span><span class="p">,</span> <span class="n">ad_method3_3</span><span class="o">&gt;</span>
<span class="o">&gt;::</span><span class="n">type</span> <span class="o">&gt;</span><span class="p">{};</span>
</pre></div>

<p>И внедрим его в класс foo2</p>

<div class="highlight"><pre>  <span class="n">foo2</span><span class="o">&lt;</span><span class="n">foo3_aspect</span><span class="o">&gt;</span> <span class="n">f3</span><span class="p">;</span>
  <span class="n">f3</span><span class="p">.</span><span class="n">method1</span><span class="p">();</span>
  <span class="n">f3</span><span class="p">.</span><span class="n">method2</span><span class="p">();</span>
  <span class="n">f3</span><span class="p">.</span><span class="n">method3</span><span class="p">();</span>
</pre></div>

<p>После внедрения произошло неявное объединение аспектов, в результате старый функционал, реализованный в адвайс-классах 
стал недоступен, но физически он остался аспекте. </p>

<p><img src="http://i.imgur.com/dYzYB.png" alt="foo3"></p>

<p>В большинстве случаев это не проблема, но при необходимости его можно удалить с помощью конструкции <a href="https://github.com/migashko/faslib/wiki/%D0%A0%D0%B5%D0%BC%D1%83%D0%B2%D0%B5%D1%80%D1%8B">remover</a>
или же наоборот обеспечить к нему доступ по другим тегам с помощью <a href="https://github.com/migashko/faslib/wiki/%D0%A4%D0%BE%D1%80%D0%B2%D0%B0%D1%80%D0%B4%D1%8B">forward</a>. Также имеется возможность связывать с 
одним адвайсом несколько тегов, с помощью псевдонимов (<a href="https://github.com/migashko/faslib/wiki/%D0%90%D0%BB%D0%B8%D0%B0%D1%81%D1%8B">alias</a>). Объединив несколько адвайсов в логическую группу ( <a href="https://github.com/migashko/faslib/wiki/%D0%93%D1%80%D1%83%D0%BF%D0%BF%D1%8B">group</a>) 
у вас появляется возможность группового вызова (аналог событий, но на этапе компиляции). Специальные адвайсы-значения 
( <a href="https://github.com/migashko/faslib/wiki/value-%D0%B0%D0%B4%D0%B2%D0%B0%D0%B9%D1%81%D1%8B">value_advice</a> ) в отличии от обычных адвайсов не наследуют тип, а агрегируют его, что позволяет включить в аспект 
простые типы, такие как int. А с помощью <a href="https://github.com/migashko/faslib/wiki/type-%D0%B0%D0%B4%D0%B2%D0%B0%D0%B9%D1%81%D1%8B">type_advice</a>, вы можете включить в аспект определение типа, например контейнера, 
и соответственно, пользователь может его заменить. </p>

<p>Для более сложных классов имеет смысл разработать несколько аспектов из адвайсов реализующих определенный функционал. 
Аспекты можно объединять явно, используя конструкцию aspect_merge.  Это позволит вам повторно использовать аспекты в 
качестве стратегий и/или комбинировать их.</p>

<p><a href="https://github.com/migashko/faslib/wiki">далее...</a></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">faslib maintained by <a href="https://github.com/migashko">migashko</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
