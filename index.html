<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>faslib by migashko</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">faslib</h1>
      <h2 class="project-tagline"></h2>
      <a href="https://github.com/migashko/faslib" class="btn">View on GitHub</a>
      <a href="https://github.com/migashko/faslib/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/migashko/faslib/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="faslib" class="anchor" href="#faslib" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>faslib</h1>

<p>Библиотека faslib предлагает новый способ модульной разработки программного обеспечения,
называемый аспекто-ориентированным, используя исключительно конструкции языка C++.</p>

<p>faslib тестировалась на следующих компиляторах:</p>

<ul>
<li>VC10</li>
<li>g++ 3.3, g++ 4.4, g++ 4.6, g++ 4.7</li>
<li>MinGW</li>
</ul>

<h2>
<a id="Установка-и-настройка" class="anchor" href="#%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Установка и настройка</h2>

<p>Компиляция не требуется, но необходимо конфигурирование с помощью cmake:</p>

<pre><code>git clone git://github.com/migashko/faslib.github
cd faslib
mkdir build
cd build
cmake ..
</code></pre>

<p>Вы также можете загрузить сконфигурированный faslib c <a href="https://sourceforge.net/projects/faslib2">sourceforge</a>.</p>

<p>Для компиляции примеров и тестов:</p>

<pre><code>make
</code></pre>

<p>или по отдельности:</p>

<pre><code>make tests
make examples
make tutorial
</code></pre>

<p>для запуска тестов:</p>

<pre><code>ctest
</code></pre>

<h2>
<a id="Введение" class="anchor" href="#%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Введение</h2>

<p>Основная идея - дать разработчику возможность разрабатывать такие классы, в которых потенциальный пользователь, при необходимости, мог бы заменить тот или иной функционал с минимумом издержек. faslib поможет вам когда:</p>

<ul>
<li>количество шаблонных стратегий для класса больше трех</li>
<li>семантически идентичный функционал используется в нескольких, не связанных между собой, классах</li>
<li>требуется заменить существующий функционал класса (реализацию одного или нескольких методов)</li>
</ul>

<p>В качестве примера рассмотрим простой класс:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">class</span> <span class="pl-en">foo1</span>
{
<span class="pl-k">public:</span>
  <span class="pl-k">void</span> <span class="pl-en">method1</span>() { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-1.1<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
  <span class="pl-k">void</span> <span class="pl-en">method2</span>() { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-1.2<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
  <span class="pl-k">void</span> <span class="pl-en">method3</span>() { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-1.3<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
};</pre></div>

<p>Предположим требуется предоставить пользователю возможность заменить функционал любого методов этого класса.
Использовать для этого полиморфизм - не лучшая идея, классические стратегии слишком накладно, шаблонные стратегии
неудобно. Более развернутые примеры (в том числе и с этими вариантами реализации) вы можете найти в <a href="https://github.com/migashko/faslib/tree/master/tutorial/aop">tutorial/aop</a>.</p>

<p>Для наглядности изобразим этот класс на картинке в виде монолитного блока:</p>

<p><img src="http://i.imgur.com/ovInI.png" alt="foo"></p>

<p>Для демонстрации возможностей разработаем класс foo2 с аналогичным функционалом, но используя концепции АОП.
Сначала разобьем его на составляющие, выделив каждый метод в отдельные сущности которые в faslib называются адвайс-классами:</p>

<p><img src="http://i.imgur.com/mof7U.png" alt="advices"></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">struct</span> <span class="pl-en">ad_method1</span>
{
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
  <span class="pl-k">void</span> <span class="pl-en">operator</span>()(T&amp;) { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-2.1<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
};

<span class="pl-k">struct</span> <span class="pl-en">ad_method2</span>
{
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
  <span class="pl-k">void</span> <span class="pl-en">operator</span>()(T&amp;) { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-2.2<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
};

<span class="pl-k">struct</span> <span class="pl-en">ad_method3</span>
{
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
  <span class="pl-k">void</span> <span class="pl-en">operator</span>()(T&amp;) { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-2.3<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
};</pre></div>

<p>Каких либо особых требований к адвайс-классам не предъявляется, но использование определенных правил
при разработке адвайс-классов существенно облегчит жизнь и вам и потенциальным пользователям. Использование перегруженного
оператора () с первым шаблонным параметром, в который передается контекст вызова (в данном случае это ссылка на foo2) является
хорошей практикой, даже если в конкретном адвайс-классе он не нужен. Дело в том, что ссылка на контекст может очень понадобиться
пользователю, который решит заменить ваш адвайс своим. Префикс “ad_” подскажет пользователю, что он имеет дело с адвайс-классом.</p>

<p>Далее для каждого адвайс-класса необходимо создать тег, по которому мы сможем обращаться к нему. Методов у нас три поэтому и
тегов нам понадобиться тоже как минимум три:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">struct</span> <span class="pl-en">_method1_</span>;
<span class="pl-k">struct</span> <span class="pl-en">_method2_</span>;
<span class="pl-k">struct</span> <span class="pl-en">_method3_</span>;</pre></div>

<p>Использование знака “_” для обрамления имени тега, чертовски удобная штука.
Следующим этапом необходимо связать теги и адвайс-классы, создав таким образом собственно адвайсы:</p>

<p><img src="http://i.imgur.com/n2diQ.png" alt="ad_method"></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">typedef</span> fas::advice&lt;_method1_, ad_method1&gt; method1_advice;
<span class="pl-k">typedef</span> fas::advice&lt;_method2_, ad_method2&gt; method2_advice;
<span class="pl-k">typedef</span> fas::advice&lt;_method3_, ad_method3&gt; method3_advice;</pre></div>

<p>Далее, необходимо объединить  разрозненные адвайсы в список типов:</p>

<p><img src="http://i.imgur.com/69b5W.png" alt="advice_list"></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">typedef</span> fas::type_list_n&lt;
  method1_advice,
  method2_advice,
  method3_advice
&gt;::type advice_list;</pre></div>

<p>Cформируем аспект foo2_aspect:</p>

<p><img src="http://i.imgur.com/KJeJq.png" alt="foo2_aspect"></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">struct</span> <span class="pl-en">foo2_aspect</span>: fas::aspect&lt; advice_list &gt;{};</pre></div>

<p>Ну и наконец разработаем сам аспектный класс foo2, в который внедрим аспект foo2_aspect:</p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> A = fas::aspect&lt;&gt; &gt;
<span class="pl-k">class</span> <span class="pl-en">foo2</span>
  : public fas::aspect_class&lt;A, foo2_aspect&gt;
{
<span class="pl-k">public:</span>
  <span class="pl-k">void</span> <span class="pl-en">method1</span>() { <span class="pl-v">this</span>-&gt;<span class="pl-c1">get_aspect</span>().<span class="pl-smi">template</span> get&lt;_method1_&gt;()( *<span class="pl-v">this</span>); }
  <span class="pl-k">void</span> <span class="pl-en">method2</span>() { <span class="pl-v">this</span>-&gt;<span class="pl-c1">get_aspect</span>().<span class="pl-smi">template</span> get&lt;_method2_&gt;()( *<span class="pl-v">this</span>); }
  <span class="pl-k">void</span> <span class="pl-en">method3</span>() { <span class="pl-v">this</span>-&gt;<span class="pl-c1">get_aspect</span>().<span class="pl-smi">template</span> get&lt;_method3_&gt;()( *<span class="pl-v">this</span>); }
};</pre></div>

<p>В реализации методов делегируем вызов необходимому адвайсу. Но в большинстве случаев компилятор выполнит inline подстановку.</p>

<p>Использовать аспектный класс foo2&lt;&gt; не сложнее обычного foo1:</p>

<div class="highlight highlight-source-c++"><pre>  foo2&lt;&gt; f2;
  f2.method1();
  f2.method2();
  f2.method3();</pre></div>

<p>Класс   foo2&lt;&gt; изобразим следующим образом:</p>

<p><img src="http://i.imgur.com/BNWNa.png" alt="foo2_aspect"></p>

<p>Полный пример <a href="https://github.com/migashko/faslib/blob/master/examples/aop/foo.cpp">здесь</a></p>

<p>Теперь попробуем заменить функционал method2 и method3, чтобы он выводил вместо строк "method-2.2" и "method-2.3", строки "method-3.2" и "method-3.3" соответственно. </p>

<p>Для этого аналогично сформируем аспект foo3_aspect:</p>

<p><img src="http://i.imgur.com/I0dIb.png" alt="foo3_aspect"></p>

<div class="highlight highlight-source-c++"><pre><span class="pl-k">struct</span> <span class="pl-en">ad_method3_2</span>
{
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
  <span class="pl-k">void</span> <span class="pl-en">operator</span>()(T&amp;) { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-3.2<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
};

<span class="pl-k">struct</span> <span class="pl-en">ad_method3_3</span>
{
  <span class="pl-k">template</span>&lt;<span class="pl-k">typename</span> T&gt;
  <span class="pl-k">void</span> <span class="pl-en">operator</span>()(T&amp;) { std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>method-3.3<span class="pl-pds">"</span></span> &lt;&lt; std::endl; }
};

<span class="pl-k">struct</span> <span class="pl-en">foo3_aspect</span>: fas::aspect&lt; fas::type_list_n&lt;
  fas::advice&lt;_method2_, ad_method3_2&gt;,
  fas::advice&lt;_method3_, ad_method3_3&gt;
&gt;::type &gt;{};</pre></div>

<p>И внедрим его в класс foo2</p>

<div class="highlight highlight-source-c++"><pre>  foo2&lt;foo3_aspect&gt; f3;
  f3.method1();
  f3.method2();
  f3.method3();</pre></div>

<p>После внедрения произошло неявное объединение аспектов, в результате старый функционал, реализованный в адвайс-классах 
стал недоступен, но физически он остался аспекте. </p>

<p><img src="http://i.imgur.com/dYzYB.png" alt="foo3"></p>

<p>В большинстве случаев это не проблема, но при необходимости его можно удалить с помощью конструкции <a href="https://github.com/migashko/faslib/wiki/%D0%A0%D0%B5%D0%BC%D1%83%D0%B2%D0%B5%D1%80%D1%8B">remover</a>
или же наоборот обеспечить к нему доступ по другим тегам с помощью <a href="https://github.com/migashko/faslib/wiki/%D0%A4%D0%BE%D1%80%D0%B2%D0%B0%D1%80%D0%B4%D1%8B">forward</a>. Также имеется возможность связывать с 
одним адвайсом несколько тегов, с помощью псевдонимов (<a href="https://github.com/migashko/faslib/wiki/%D0%90%D0%BB%D0%B8%D0%B0%D1%81%D1%8B">alias</a>). Объединив несколько адвайсов в логическую группу ( <a href="https://github.com/migashko/faslib/wiki/%D0%93%D1%80%D1%83%D0%BF%D0%BF%D1%8B">group</a>) 
у вас появляется возможность группового вызова (аналог событий, но на этапе компиляции). Специальные адвайсы-значения 
( <a href="https://github.com/migashko/faslib/wiki/value-%D0%B0%D0%B4%D0%B2%D0%B0%D0%B9%D1%81%D1%8B">value_advice</a> ) в отличии от обычных адвайсов не наследуют тип, а агрегируют его, что позволяет включить в аспект 
простые типы, такие как int. А с помощью <a href="https://github.com/migashko/faslib/wiki/type-%D0%B0%D0%B4%D0%B2%D0%B0%D0%B9%D1%81%D1%8B">type_advice</a>, вы можете включить в аспект определение типа, например контейнера, 
и соответственно, пользователь может его заменить. </p>

<p>Для более сложных классов имеет смысл разработать несколько аспектов из адвайсов реализующих определенный функционал. 
Аспекты можно объединять явно, используя конструкцию aspect_merge.  Это позволит вам повторно использовать аспекты в 
качестве стратегий и/или комбинировать их.</p>

<p><a href="https://github.com/migashko/faslib/wiki">далее...</a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/migashko/faslib">faslib</a> is maintained by <a href="https://github.com/migashko">migashko</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
