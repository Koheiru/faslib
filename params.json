{"tagline":"","body":"# faslib\r\n\r\nБиблиотека faslib предлагает новый способ модульной разработки программного обеспечения,\r\nназываемый аспекто-ориентированным, используя исключительно конструкции языка C++.\r\n\r\nfaslib тестировалась на следующих компиляторах:\r\n\r\n* VC10\r\n* g++ 3.3, g++ 4.4, g++ 4.6, g++ 4.7\r\n* MinGW\r\n\r\n## Установка и настройка\r\n\r\nКомпиляция не требуется, но необходимо конфигурирование с помощью cmake\r\n```\r\ngit clone git://github.com/migashko/faslib.github\r\ncd faslib\r\nmkdir build\r\ncd build\r\ncmake ..\r\n```\r\n\r\nДля компиляции примеров и тестов\r\n```\r\nmake\r\n```\r\n\r\nили по отдельности\r\n```\r\nmake tests\r\nmake examples\r\nmake tutorial\r\n```\r\n\r\nдля запуска тестов\r\n```\r\nctest\r\n```\r\n\r\n## Введение\r\n\r\nОсновная идея - дать разработчику возможность разрабатывать такие классы, в которых потенциальный пользователь,\r\nпри необходимости, мог бы заменить тот или иной функционал с минимумом издержек.\r\n\r\nВ качестве примера рассмотрим простой класс:\r\n\r\n```cpp\r\nclass foo1\r\n{\r\npublic:\r\n  void method1() { std::cout << \"method-1.1\" << std::endl; }\r\n  void method2() { std::cout << \"method-1.2\" << std::endl; }\r\n  void method3() { std::cout << \"method-1.3\" << std::endl; }\r\n};\r\n```\r\n\r\nПредположим требуется предоставить пользователю возможность заменить функционал любого методов этого класса.\r\nИспользовать для этого полиморфизм - не лучшая идея, классические стратегии слишком накладно, шаблонные стратегии\r\nнеудобно. Более развернутые примеры (в том числе и с этими вариантами реализации) вы можете найти в [tutorial/aop](https://github.com/migashko/faslib/tree/master/tutorial/aop).\r\n\r\nДля наглядности изобразим этот класс на картинке в виде монолитного блока:\r\n\r\n![foo](https://github.com/migashko/faslib/blob/gh-pages/images/fas/image05.png?raw=true)\r\n\r\nДля демонстрации возможностей разработаем класс foo2 с аналогичным функционалом, но используя концепции АОП.\r\nСначала разобьем его на составляющие, выделив каждый метод в отдельные сущности которые в faslib называются адвайс-классами:\r\n\r\n![ad_method](https://github.com/migashko/faslib/blob/gh-pages/images/fas/image00.png?raw=true)\r\n\r\n```cpp\r\nstruct ad_method1\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-2.1\" << std::endl; }\r\n};\r\n\r\nstruct ad_method2\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-2.2\" << std::endl; }\r\n};\r\n\r\nstruct ad_method3\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-2.3\" << std::endl; }\r\n};\r\n```\r\n\r\nКаких либо особых требований к адвайс-классам не предъявляется, но использование определенных правил\r\nпри разработке адвайс-классов существенно облегчит жизнь и вам и потенциальным пользователям. Использование перегруженного\r\nоператора () с первым шаблонным параметром, в который передается контекст вызова (в данном случае это ссылка на foo2) является\r\nхорошей практикой, даже если в конкретном адвайс-классе он не нужен. Дело в том, что ссылка на контекст может очень понадобиться\r\nпользователю, который решит заменить ваш адвайс своим. Префикс “ad_” подскажет пользователю, что он имеет дело с адвайс-классом.\r\n\r\nДалее для каждого адвайс-класса необходимо создать тег, по которому мы сможем обращаться к нему. Методов у нас три поэтому и\r\nтегов нам понадобиться тоже как минимум три:\r\n\r\n```cpp\r\nstruct _method1_;\r\nstruct _method2_;\r\nstruct _method3_;\r\n```\r\n\r\nИспользование знака “_” для обрамления имени тега, чертовски удобная штука.\r\nСледующим этапом необходимо связать теги и адвайс-классы, создав таким образом собственно адвайсы:\r\n\r\n![advices](https://github.com/migashko/faslib/blob/gh-pages/images/fas/image07.png?raw=true)\r\n\r\n```cpp\r\ntypedef fas::advice<_method1_, ad_method1> method1_advice;\r\ntypedef fas::advice<_method2_, ad_method2> method2_advice;\r\ntypedef fas::advice<_method3_, ad_method3> method3_advice;\r\n```\r\n\r\nДалее, необходимо объединить  разрозненные адвайсы в список типов:\r\n\r\n![advice list](https://github.com/migashko/faslib/blob/gh-pages/images/fas/image01.png?raw=true)\r\n\r\n```cpp\r\ntypedef fas::type_list_n<\r\n  method1_advice,\r\n  method2_advice,\r\n  method3_advice\r\n>::type advice_list;\r\n```\r\n\r\nCформируем аспект foo2_aspect:\r\n\r\n![foo2_aspect](https://github.com/migashko/faslib/blob/gh-pages/images/fas/image06.png?raw=true)\r\n\r\n```cpp\r\nstruct foo2_aspect: fas::aspect< advice_list >{};\r\n```\r\n\r\nНу и наконец разработаем сам аспектный класс foo2, в который внедрим аспект foo2_aspect:\r\n\r\n```cpp\r\ntemplate<typename A = fas::aspect<> >\r\nclass foo2\r\n  : public fas::aspect_class<A, foo2_aspect>\r\n{\r\npublic:\r\n  void method1() { this->get_aspect().template get<_method1_>()( *this); }\r\n  void method2() { this->get_aspect().template get<_method2_>()( *this); }\r\n  void method3() { this->get_aspect().template get<_method3_>()( *this); }\r\n};\r\n```\r\nВ реализации методов делегируем вызов необходимому адвайсу. Но в большинстве случаев компилятор выполнит inline подстановку.\r\n\r\nИспользовать аспектный класс foo2<> не сложнее обычного foo1:\r\n\r\n```cpp\r\n  foo2<> f2;\r\n  f2.method1();\r\n  f2.method2();\r\n  f2.method3();\r\n```\r\n\r\nКласс   foo2<> изобразим следующим образом:\r\n\r\n![foo2_aspect](https://github.com/migashko/faslib/blob/gh-pages/images/fas/image03.png?raw=true)\r\n\r\nПолный пример [здесь](https://github.com/migashko/faslib/blob/master/examples/aop/foo.cpp)\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"faslib"}