{"tagline":"faslib, C++, AOP, Type list","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# faslib\r\n\r\nБиблиотека faslib предлагает новый способ модульной разработки программного обеспечения,\r\nназываемый аспекто-ориентированным, используя исключительно конструкции языка C++.\r\n\r\nfaslib тестировалась на следующих компиляторах:\r\n\r\n* VC10\r\n* g++ 3.3, g++ 4.4, g++ 4.6, g++ 4.7\r\n* MinGW\r\n\r\n## Установка и настройка\r\n\r\nКомпиляция не требуется, но необходимо конфигурирование с помощью cmake:\r\n```\r\ngit clone git://github.com/migashko/faslib.github\r\ncd faslib\r\nmkdir build\r\ncd build\r\ncmake ..\r\n```\r\n\r\nВы также можете загрузить сконфигурированный faslib c [sourceforge](https://sourceforge.net/projects/faslib2).\r\n\r\nДля компиляции примеров и тестов:\r\n```\r\nmake\r\n```\r\n\r\nили по отдельности:\r\n```\r\nmake tests\r\nmake examples\r\nmake tutorial\r\n```\r\n\r\nдля запуска тестов:\r\n```\r\nctest\r\n```\r\n\r\n## Введение\r\n\r\nОсновная идея - дать разработчику возможность разрабатывать такие классы, в которых потенциальный пользователь, при необходимости, мог бы заменить тот или иной функционал с минимумом издержек. faslib поможет вам когда:\r\n* количество шаблонных стратегий для класса больше трех\r\n* семантически идентичный функционал используется в нескольких, не связанных между собой, классах\r\n* требуется заменить существующий функционал класса (реализацию одного или нескольких методов)\r\n\r\nВ качестве примера рассмотрим простой класс:\r\n\r\n```cpp\r\nclass foo1\r\n{\r\npublic:\r\n  void method1() { std::cout << \"method-1.1\" << std::endl; }\r\n  void method2() { std::cout << \"method-1.2\" << std::endl; }\r\n  void method3() { std::cout << \"method-1.3\" << std::endl; }\r\n};\r\n```\r\n\r\nПредположим требуется предоставить пользователю возможность заменить функционал любого методов этого класса.\r\nИспользовать для этого полиморфизм - не лучшая идея, классические стратегии слишком накладно, шаблонные стратегии\r\nнеудобно. Более развернутые примеры (в том числе и с этими вариантами реализации) вы можете найти в [tutorial/aop](https://github.com/migashko/faslib/tree/master/tutorial/aop).\r\n\r\nДля наглядности изобразим этот класс на картинке в виде монолитного блока:\r\n\r\n![foo](http://i.imgur.com/ovInI.png)\r\n\r\nДля демонстрации возможностей разработаем класс foo2 с аналогичным функционалом, но используя концепции АОП.\r\nСначала разобьем его на составляющие, выделив каждый метод в отдельные сущности которые в faslib называются адвайс-классами:\r\n\r\n![ad_method](http://i.imgur.com/n2diQ.png)\r\n\r\n```cpp\r\nstruct ad_method1\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-2.1\" << std::endl; }\r\n};\r\n\r\nstruct ad_method2\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-2.2\" << std::endl; }\r\n};\r\n\r\nstruct ad_method3\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-2.3\" << std::endl; }\r\n};\r\n```\r\n\r\nКаких либо особых требований к адвайс-классам не предъявляется, но использование определенных правил\r\nпри разработке адвайс-классов существенно облегчит жизнь и вам и потенциальным пользователям. Использование перегруженного\r\nоператора () с первым шаблонным параметром, в который передается контекст вызова (в данном случае это ссылка на foo2) является\r\nхорошей практикой, даже если в конкретном адвайс-классе он не нужен. Дело в том, что ссылка на контекст может очень понадобиться\r\nпользователю, который решит заменить ваш адвайс своим. Префикс “ad_” подскажет пользователю, что он имеет дело с адвайс-классом.\r\n\r\nДалее для каждого адвайс-класса необходимо создать тег, по которому мы сможем обращаться к нему. Методов у нас три поэтому и\r\nтегов нам понадобиться тоже как минимум три:\r\n\r\n```cpp\r\nstruct _method1_;\r\nstruct _method2_;\r\nstruct _method3_;\r\n```\r\n\r\nИспользование знака “_” для обрамления имени тега, чертовски удобная штука.\r\nСледующим этапом необходимо связать теги и адвайс-классы, создав таким образом собственно адвайсы:\r\n\r\n![advices](http://i.imgur.com/mof7U.png)\r\n\r\n```cpp\r\ntypedef fas::advice<_method1_, ad_method1> method1_advice;\r\ntypedef fas::advice<_method2_, ad_method2> method2_advice;\r\ntypedef fas::advice<_method3_, ad_method3> method3_advice;\r\n```\r\n\r\nДалее, необходимо объединить  разрозненные адвайсы в список типов:\r\n\r\n![advice_list](http://i.imgur.com/69b5W.png)\r\n\r\n```cpp\r\ntypedef fas::type_list_n<\r\n  method1_advice,\r\n  method2_advice,\r\n  method3_advice\r\n>::type advice_list;\r\n```\r\n\r\nCформируем аспект foo2_aspect:\r\n\r\n![foo2_aspect](http://i.imgur.com/KJeJq.png)\r\n\r\n```cpp\r\nstruct foo2_aspect: fas::aspect< advice_list >{};\r\n```\r\n\r\nНу и наконец разработаем сам аспектный класс foo2, в который внедрим аспект foo2_aspect:\r\n\r\n```cpp\r\ntemplate<typename A = fas::aspect<> >\r\nclass foo2\r\n  : public fas::aspect_class<A, foo2_aspect>\r\n{\r\npublic:\r\n  void method1() { this->get_aspect().template get<_method1_>()( *this); }\r\n  void method2() { this->get_aspect().template get<_method2_>()( *this); }\r\n  void method3() { this->get_aspect().template get<_method3_>()( *this); }\r\n};\r\n```\r\nВ реализации методов делегируем вызов необходимому адвайсу. Но в большинстве случаев компилятор выполнит inline подстановку.\r\n\r\nИспользовать аспектный класс foo2<> не сложнее обычного foo1:\r\n\r\n```cpp\r\n  foo2<> f2;\r\n  f2.method1();\r\n  f2.method2();\r\n  f2.method3();\r\n```\r\n\r\nКласс   foo2<> изобразим следующим образом:\r\n\r\n![foo2_aspect](http://i.imgur.com/BNWNa.png)\r\n\r\nПолный пример [здесь](https://github.com/migashko/faslib/blob/master/examples/aop/foo.cpp)\r\n\r\nТеперь попробуем заменить функционал method2 и method3, чтобы он выводил вместо строк \"method-2.2\" и \"method-2.3\", строки \"method-3.2\" и \"method-3.3\" соответственно. \r\n\r\nДля этого аналогично сформируем аспект foo3_aspect:\r\n\r\n![foo3_aspect](http://i.imgur.com/I0dIb.png)\r\n\r\n```cpp\r\nstruct ad_method3_2\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-3.2\" << std::endl; }\r\n};\r\n\r\nstruct ad_method3_3\r\n{\r\n  template<typename T>\r\n  void operator()(T&) { std::cout << \"method-3.3\" << std::endl; }\r\n};\r\n\r\nstruct foo3_aspect: fas::aspect< fas::type_list_n<\r\n  fas::advice<_method2_, ad_method3_2>,\r\n  fas::advice<_method3_, ad_method3_3>\r\n>::type >{};\r\n```\r\n\r\nИ внедрим его в класс foo2\r\n\r\n```cpp\r\n  foo2<foo3_aspect> f3;\r\n  f3.method1();\r\n  f3.method2();\r\n  f3.method3();\r\n```\r\n\r\nПосле внедрения произошло неявное объединение аспектов, в результате старый функционал, реализованный в адвайс-классах \r\nстал недоступен, но физически он остался аспекте. \r\n\r\n![foo3](http://i.imgur.com/dYzYB.png)\r\n\r\nВ большинстве случаев это не проблема, но при необходимости его можно удалить с помощью конструкции [remover](https://github.com/migashko/faslib/wiki/%D0%A0%D0%B5%D0%BC%D1%83%D0%B2%D0%B5%D1%80%D1%8B)\r\nили же наоборот обеспечить к нему доступ по другим тегам с помощью [forward](https://github.com/migashko/faslib/wiki/%D0%A4%D0%BE%D1%80%D0%B2%D0%B0%D1%80%D0%B4%D1%8B). Также имеется возможность связывать с \r\nодним адвайсом несколько тегов, с помощью псевдонимов ([alias](https://github.com/migashko/faslib/wiki/%D0%90%D0%BB%D0%B8%D0%B0%D1%81%D1%8B)). Объединив несколько адвайсов в логическую группу ( [group](https://github.com/migashko/faslib/wiki/%D0%93%D1%80%D1%83%D0%BF%D0%BF%D1%8B)) \r\nу вас появляется возможность группового вызова (аналог событий, но на этапе компиляции). Специальные адвайсы-значения \r\n( [value_advice](https://github.com/migashko/faslib/wiki/value-%D0%B0%D0%B4%D0%B2%D0%B0%D0%B9%D1%81%D1%8B) ) в отличии от обычных адвайсов не наследуют тип, а агрегируют его, что позволяет включить в аспект \r\nпростые типы, такие как int. А с помощью [type_advice](https://github.com/migashko/faslib/wiki/type-%D0%B0%D0%B4%D0%B2%D0%B0%D0%B9%D1%81%D1%8B), вы можете включить в аспект определение типа, например контейнера, \r\nи соответственно, пользователь может его заменить. \r\n\r\nДля более сложных классов имеет смысл разработать несколько аспектов из адвайсов реализующих определенный функционал. \r\nАспекты можно объединять явно, используя конструкцию aspect_merge.  Это позволит вам повторно использовать аспекты в \r\nкачестве стратегий и/или комбинировать их.\r\n\r\n[далее...]  https://github.com/migashko/faslib/wiki\r\n","name":"faslib"}